/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Compiler/Parser.ts":
/*!********************************!*\
  !*** ./src/Compiler/Parser.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parsect_1 = __webpack_require__(/*! ./lib/parsect */ \"./src/Compiler/lib/parsect.ts\");\nconst pTerminator = parsect_1.Parsect.string(\";\");\nconst pSpaces = parsect_1.Parsect.spaces;\nconst identifier = parsect_1.Parsect.seq(s => {\n    s(parsect_1.Parsect.letter);\n    s(parsect_1.Parsect.many(parsect_1.Parsect.alphaNum));\n});\nconst pUseStatement = parsect_1.Parsect.seq(s => {\n    s(parsect_1.Parsect.string(\"use\"));\n    s(pSpaces);\n    s(identifier);\n    if (s.success) {\n        console.log(s);\n    }\n    s(pTerminator);\n});\nconst pStatement = parsect_1.Parsect.or(pUseStatement);\nconst parse = (src) => {\n    const state = parsect_1.Parsect.state(src);\n    const res = parsect_1.Parsect.parse(pStatement, state);\n    console.log(res);\n};\nexports.default = parse;\n\n\n//# sourceURL=webpack:///./src/Compiler/Parser.ts?");

/***/ }),

/***/ "./src/Compiler/lib/parsect.ts":
/*!*************************************!*\
  !*** ./src/Compiler/lib/parsect.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//                            Parsect\n//\n//          Parser Combinator Library for JavaScript/TypeScript\n//\n//                           Revision 2\n//\n//\n//\n//             site: https://github.com/kontan/Parsect\n//                author: Kon (http://phyzkit.net/)\n//\n//\n//\n//                         The MIT License\n//\n//                      Copyright (c) 2013 Kon\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n// @ts-nocheck\n// Note: All properties of objects of Persect are readonly unless any indication is given.\n// All function don't accept `null` as a parameter.\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parsect = void 0;\nvar Parsect;\n(function (Parsect) {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Data Type Definitions ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Current parsing state.\n    // <U> Type of user state.\n    class State {\n        // You can use `state` function instead of `new State`.\n        constructor(source, position = 0, _userState) {\n            this.source = source;\n            this.position = position;\n            this._userState = _userState;\n            assert(typeof source !== \"undefined\");\n            assert(source !== null);\n            if (position < 0 || position > source.length + 1)\n                throw \"_position: out of range: \" + position;\n        }\n        getRowColumn() {\n            var lines = this.source.split(\"\\n\");\n            var position = 0;\n            var raw = 0;\n            while (position < this.position) {\n                if (this.position <= position + lines[raw].length)\n                    break;\n                position += lines[raw].length + 1;\n                raw++;\n            }\n            var column = this.position - position;\n            return { raw: raw, column: column };\n        }\n        seek(delta) {\n            return new State(this.source, this.position + delta, this._userState);\n        }\n        equals(src) {\n            return src && this.source === src.source && this.position === src.position && jsonEq(this._userState, src._userState);\n        }\n    }\n    Parsect.State = State;\n    // Create new state object.\n    function state(source, position = 0, userState) {\n        return new State(source, position, userState);\n    }\n    Parsect.state = state;\n    /// Result of parsing.\n    /// (equiv. Text.Parsec.Prim.Reply)\n    /// <A>　Type of semantic value.\n    /// <U> Type of User state.\n    class Reply {\n        /// private constructor.\n        /// You should use success or fail functions instead of this constructor.\n        constructor(state, success, value, expected) {\n            this.state = state;\n            this.success = success;\n            this.value = value;\n            this.expected = expected;\n        }\n        equals(st) {\n            return st &&\n                this.state.equals(st.state) &&\n                this.success === st.success &&\n                (this.success ? jsonEq(this.value, st.value) : ((this.expected === undefined && st.expected === undefined) || (this.expected() === st.expected())));\n        }\n    }\n    Parsect.Reply = Reply;\n    /// create new successful state.\n    /// (equiv. Text.Parsec.Prim.OK)\n    /// @param state    a state after parsing.\n    /// @param value    semantic value.\n    function ok(state, value) {\n        return new Reply(state, true, value, undefined);\n    }\n    Parsect.ok = ok;\n    /// create new failure state.\n    /// (equiv. Text.Parsec.Prim.Error)\n    /// @param state    a state after parsing.\n    /// @param expected\n    function error(state, expected) {\n        return new Reply(state, false, undefined, expected);\n    }\n    Parsect.error = error;\n    /// parser object.\n    /// <A> Type of Semantic value.\n    class Parser {\n        /// create new parser.\n        /// @param parse parsing function\n        /// @param expecting human-readable string description that this parser expecting.\n        constructor(runParser) {\n            this.runParser = runParser;\n        }\n    }\n    Parsect.Parser = Parser;\n    /// Parse an input.\n    /// This function acceps string primitive value as string parser or RegExp object as regexp parser.\n    /// @param parser parser.\n    /// @param state state.\n    /// @return the result of parssing.\n    function parse(parser, state) {\n        //assert( !! parser);\n        return parser.runParser(state);\n    }\n    Parsect.parse = parse;\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Parser Combinators (Text.Parsec.Combinator) ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Choice parser combinators //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /// (equiv. Text.Parsec.Combinator.choice)\n    function choice(ps) {\n        function choiceParser(state) {\n            // For debugging　and efficiency, expand list as loop intentionally.\n            var sts = [];\n            for (var i = 0; i < ps.length; i++) {\n                var st = parse(ps[i], state);\n                if (st.success || st.state.position != state.position) {\n                    return st;\n                }\n                sts.push(st);\n            }\n            return error(state, () => \"one of \" + sts.map(st => st.expected()).join(','));\n        }\n        return new Parser(choiceParser);\n    }\n    Parsect.choice = choice;\n    /// Variable parameter version of `choice`.\n    function or(...ps) {\n        return choice(ps);\n    }\n    Parsect.or = or;\n    // Repetitious parser constructors ////////////////////////////////////////////////////////////////////////////////////////\n    /// `repeat n m p` parses `n` occurrences of `p` at minimum, parses `m` occurrences of `p` at maximum.\n    function repeat(min, max, p) {\n        function repeatParser(s) {\n            // For debugging　and efficiency, expand list as loop intentionally.\n            var xs = [];\n            var st = ok(s, undefined);\n            for (var i = 0; i < max; i++) {\n                var _st = parse(p, st.state);\n                if (_st.success) {\n                    if (_st.state.position === st.state.position && max === Number.MAX_VALUE) {\n                        throw new Error(\"many combinator is applied to a parser that accepts an empty string.\");\n                    }\n                    else {\n                        st = _st;\n                        xs.push(st.value);\n                    }\n                }\n                else if (st.state.position < _st.state.position) {\n                    return _st;\n                }\n                else if (i < min) {\n                    return _st;\n                }\n                else {\n                    break;\n                }\n            }\n            return ok(st.state, xs);\n        }\n        return new Parser(repeatParser);\n    }\n    Parsect.repeat = repeat;\n    /// (equiv. Text.Parsec.Combinator.count)\n    function count(n, p) {\n        return repeat(n, n, p);\n    }\n    Parsect.count = count;\n    /// (equiv. Text.Parsec.Combinator.many)\n    function many(p) {\n        return repeat(0, Number.MAX_VALUE, p);\n    }\n    Parsect.many = many;\n    /// (equiv. Text.Parsec.Combinator.many1)\n    function many1(p) {\n        return repeat(1, Number.MAX_VALUE, p);\n    }\n    Parsect.many1 = many1;\n    // Sequential parser constructors ///////////////////////////////////////////////////////////////////////////////////////\n    /// `array ps` parses the parser of `ps` sequentially and return the reply of those parsers.\n    function array(ps) {\n        function arrayParser(state) {\n            var values = [];\n            var st = ok(state, undefined);\n            for (var i = 0; i < ps.length; i++) {\n                st = parse(ps[i], st.state);\n                if (!st.success)\n                    return error(st.state, st.expected);\n                values.push(st.value);\n            }\n            return ok(st.state, values);\n        }\n        return new Parser(arrayParser);\n    }\n    Parsect.array = array;\n    /// variable parameters version of `array`.\n    function series(...ps) {\n        return array(ps);\n    }\n    Parsect.series = series;\n    /// `head(a, b, c, ...)` parses `a`, `b`, `c` and etc, and returns reply of `a`.\n    function head(p, ...ps) {\n        function headParser(state) {\n            var st = parse(p, state);\n            var value = st.value;\n            for (var i = 0; i < ps.length && st.success; i++) {\n                st = parse(ps[i], st.state);\n            }\n            return st.success ? ok(st.state, value) : st;\n        }\n        return new Parser(headParser);\n    }\n    Parsect.head = head;\n    /// (equiv. Text.Parsec.Combinator.between)\n    function between(open, p, close) {\n        return seq(s => {\n            s(open);\n            var v = s(p);\n            s(close);\n            return v;\n        });\n    }\n    Parsect.between = between;\n    /// Do-notation like parsing control flow.\n    /// @param f    callback function\n    function seq(f) {\n        assert(f instanceof Function);\n        function seqParser(state) {\n            var st = ok(state, undefined);\n            function contextFunction(p) {\n                if (st.success) {\n                    st = parse(p, st.state);\n                    context.success = st.success;\n                    return st.value;\n                }\n            }\n            var context = contextFunction;\n            context.success = true;\n            context.userState = st.state._userState;\n            var value = f(context);\n            st.state._userState = context.userState;\n            return context.success ? ok(st.state, value) : st;\n        }\n        return new Parser(seqParser);\n    }\n    Parsect.seq = seq;\n    // Alternative parser constructors /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///\n    function sepByN(min, max, p, sep) {\n        assert(p instanceof Parser);\n        assert(sep instanceof Parser);\n        assert(min <= max);\n        function sepByNParser(source) {\n            var xs = [];\n            var st = ok(source, undefined);\n            var _st = parse(p, st.state);\n            if (_st.success) {\n                st = _st;\n                xs.push(_st.value);\n                for (var i = 1; i < max; i++) {\n                    var _st = parse(sep, st.state);\n                    if (_st.success) {\n                        st = parse(p, _st.state);\n                        if (st.success) {\n                            xs.push(st.value);\n                            continue;\n                        }\n                    }\n                    else if (xs.length < min) {\n                        return _st;\n                    }\n                    break;\n                }\n            }\n            else if (xs.length < min) {\n                return _st;\n            }\n            return st.success ? ok(st.state, xs) : st;\n        }\n        return new Parser(sepByNParser);\n    }\n    Parsect.sepByN = sepByN;\n    function sepBy1(p, sep) {\n        return sepByN(1, Number.MAX_VALUE, p, sep);\n    }\n    Parsect.sepBy1 = sepBy1;\n    function sepBy(p, sep) {\n        return sepByN(0, Number.MAX_VALUE, p, sep);\n    }\n    Parsect.sepBy = sepBy;\n    function endByN(min, max, p, sep) {\n        return repeat(min, max, head(p, sep));\n    }\n    Parsect.endByN = endByN;\n    function endBy1(p, sep) {\n        return endByN(1, Number.MAX_VALUE, p, sep);\n    }\n    Parsect.endBy1 = endBy1;\n    function endBy(p, sep) {\n        return endByN(0, Number.MAX_VALUE, p, sep);\n    }\n    Parsect.endBy = endBy;\n    // Optional parser constructors ///////////////////////////////////////////////////////////////////////////////////////////\n    function option(defaultValue, p) {\n        return or(p, pure(defaultValue));\n    }\n    Parsect.option = option;\n    function optional(p) {\n        return option(undefined, p);\n    }\n    Parsect.optional = optional;\n    // Build-in Parsees /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Parsect.eof = new Parser((state) => state.position === state.source.length ? ok(state.seek(1), undefined) : error(state, () => \"end of file\"));\n    Parsect.empty = new Parser((state) => ok(state, undefined));\n    Parsect.number = fmap(parseFloat, regexp(/^[-+]?\\d+(\\.\\d+)?/));\n    function fail(message) {\n        return new Parser((state) => error(state, () => message));\n    }\n    Parsect.fail = fail;\n    function unexpected(message) {\n        function unexpectedParser(state) {\n            return error(state, () => message);\n        }\n        return new Parser(unexpectedParser);\n    }\n    Parsect.unexpected = unexpected;\n    function skipMany(p) {\n        return fmap((_) => undefined, many(p));\n    }\n    Parsect.skipMany = skipMany;\n    function skipMany1(p) {\n        return seq(s => {\n            s(p);\n            s(skipMany(p));\n        });\n    }\n    Parsect.skipMany1 = skipMany1;\n    // Special parser constructors /////////////////////////////////////////////////////////////////////////////////////////////\n    /*\n        export function apply<A,B,            R>(m: (a: A, b: B                                   )=>R, pa: Parser<A>, pb: Parser<B>                                                                                          ): Parser<R>;\n        export function apply<A,B,C,          R>(m: (a: A, b: B, c: C                             )=>R, pa: Parser<A>, pb: Parser<B>, pc: Parser<C>                                                                           ): Parser<R>;\n        export function apply<A,B,C,D,        R>(m: (a: A, b: B, c: C, d: D                       )=>R, pa: Parser<A>, pb: Parser<B>, pc: Parser<C>, pd: Parser<D>                                                            ): Parser<R>;\n        export function apply<A,B,C,D,E,      R>(m: (a: A, b: B, c: C, d: D, e: E                 )=>R, pa: Parser<A>, pb: Parser<B>, pc: Parser<C>, pd: Parser<D>, pe: Parser<E>                                             ): Parser<R>;\n        export function apply<A,B,C,D,E,F,    R>(m: (a: A, b: B, c: C, d: D, e: E, f: F           )=>R, pa: Parser<A>, pb: Parser<B>, pc: Parser<C>, pd: Parser<D>, pe: Parser<E>, pf: Parser<F>                              ): Parser<R>;\n        export function apply<A,B,C,D,E,F,G,  R>(m: (a: A, b: B, c: C, d: D, e: E, f: F, g: G     )=>R, pa: Parser<A>, pb: Parser<B>, pc: Parser<C>, pd: Parser<D>, pe: Parser<E>, pf: Parser<F>, pg: Parser<G>               ): Parser<R>;\n        export function apply<A,B,C,D,E,F,G,H,R>(m: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h:H)=>R, pa: Parser<A>, pb: Parser<B>, pc: Parser<C>, pd: Parser<D>, pe: Parser<E>, pf: Parser<F>, pg: Parser<G>, ph: Parser<H>): Parser<R>;\n        export function apply(func: Function, ...ps: Parser<any>[]): Parser<any> {\n            assert(func instanceof Function);\n            return fmap((xs: any[])=>func.apply(undefined, xs), array(ps))\n        }\n    */\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Primitive parsers (Text.Parsec.Prim) ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function label(message, p) {\n        function labelParser(state) {\n            var reply = parse(p, state);\n            return ((!reply.success) && reply.state.position === state.position) ? error(state, () => message) : reply;\n        }\n        return new Parser(labelParser);\n    }\n    Parsect.label = label;\n    function lookAhead(p) {\n        function lookAheadParser(state) {\n            var st = parse(p, state);\n            return st.success ? ok(state, st.value) : st;\n        }\n        return new Parser(lookAheadParser);\n    }\n    Parsect.lookAhead = lookAhead;\n    function pure(t) {\n        return fmap(() => t, Parsect.empty);\n    }\n    Parsect.pure = pure;\n    function triable(p) {\n        function triableParser(state) {\n            var st = parse(p, state);\n            return st.success ? st : error(state, st.expected);\n        }\n        return new Parser(triableParser);\n    }\n    Parsect.triable = triable;\n    function notFollowedBy(p) {\n        function notFollowedByParser(state) {\n            var rep = parse(p, state);\n            return rep.success ? error(state, () => 'not ' + rep.value) : ok(state, undefined);\n        }\n        return new Parser(notFollowedByParser);\n    }\n    Parsect.notFollowedBy = notFollowedBy;\n    function fmap(f, p) {\n        function mapParser(state) {\n            var st = parse(p, state);\n            return st.success ? ok(st.state, f(st.value)) : st;\n        }\n        return new Parser(mapParser);\n    }\n    Parsect.fmap = fmap;\n    function lazy(f) {\n        assert(f instanceof Function);\n        function lazyParser(state) {\n            return parse(f(), state);\n        }\n        return new Parser(lazyParser);\n    }\n    Parsect.lazy = lazy;\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Charactor parser constructor (Text.Parsec.Char) /////////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function oneOf(chars) {\n        return satisfy(c => chars.indexOf(c) >= 0);\n    }\n    Parsect.oneOf = oneOf;\n    function noneOf(chars) {\n        return satisfy(c => chars.indexOf(c) == -1);\n    }\n    Parsect.noneOf = noneOf;\n    Parsect.space = oneOf(\" \\t\\r\\n\");\n    Parsect.spaces = fmap(xs => xs.join(), many(Parsect.space));\n    Parsect.newline = oneOf(\"\\r\\n\");\n    Parsect.tab = char(\"\\t\");\n    Parsect.upper = oneOf(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    Parsect.lower = oneOf(\"abcdefghijklmnopqrstuvwxyz\");\n    Parsect.alphaNum = oneOf(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\");\n    Parsect.letter = oneOf(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n    Parsect.digit = oneOf(\"0123456789\");\n    Parsect.hexDigit = oneOf(\"0123456789abcdefghABCDEFGH\");\n    Parsect.octDigit = oneOf(\"01234567\");\n    function char(c) {\n        assert(c && c.length === 1);\n        return satisfy(_c => c === _c);\n    }\n    Parsect.char = char;\n    Parsect.anyChar = satisfy(_ => true);\n    /// `satisfy cond` returns a parser consume a charactor that satisfy the condition `cond`\n    function satisfy(condition) {\n        assert(condition instanceof Function);\n        function expectedChars() {\n            var cs = [];\n            for (var i = 32; i <= 126; i++) {\n                var c = String.fromCharCode(i);\n                if (condition(c, i)) {\n                    cs.push(c);\n                }\n            }\n            return cs;\n        }\n        function satisfyParser(s) {\n            if (s.position < s.source.length) {\n                var c = s.source[s.position];\n                var i = s.source.charCodeAt(s.position);\n                if (condition(c, i)) {\n                    return ok(s.seek(1), c);\n                }\n            }\n            return error(s, () => {\n                var cs = expectedChars();\n                return (cs.length === 1 ? \"\" : \"one of \") + \"\\\"\" + cs.join('') + \"\\\"\";\n            });\n        }\n        return new Parser(satisfyParser);\n    }\n    Parsect.satisfy = satisfy;\n    /// string parser\n    function string(text, caseSensitive = true) {\n        assert(typeof text === \"string\" || text instanceof String);\n        text = caseSensitive ? text : text.toLowerCase();\n        function stringParser(s) {\n            var slice = s.source.slice(s.position, s.position + text.length);\n            return text === (caseSensitive ? slice : slice.toLowerCase()) ? ok(s.seek(text.length), text) : error(s, () => \"\\\"\" + text + \"\\\"\");\n        }\n        return new Parser(stringParser);\n    }\n    Parsect.string = string;\n    // regular expression parser\n    function regexp(pattern) {\n        assert(pattern instanceof RegExp);\n        function regexpParser(s) {\n            var input = s.source.slice(s.position);\n            pattern.lastIndex = 0;\n            var ms = pattern.exec(input);\n            // In javascript' Regex, ^ matches not only the benning of the input but the beginniing of new line.\n            //  \"input.indexOf(matches[0]) == 0\" is needed.\n            if (ms && ms.index == 0 && ms.length > 0) {\n                var m = ms[0];\n                return input.indexOf(ms[0]) == 0 ? ok(s.seek(m.length), m) : error(s, () => \"/\" + pattern + \"/\");\n            }\n            else {\n                return error(s, () => \"\" + pattern);\n            }\n        }\n        return new Parser(regexpParser);\n    }\n    Parsect.regexp = regexp;\n    function range(min, max) {\n        assert(((typeof min === \"number\" || min instanceof Number) &&\n            (typeof min === \"number\" || min instanceof Number)) || ((typeof min === \"string\" || min instanceof String) && (min.length === 1) &&\n            (typeof min === \"string\" || min instanceof String) && (max.length === 1)));\n        min = (typeof min === \"string\" || min instanceof String) ? min.charCodeAt(0) : min;\n        max = (typeof min === \"string\" || min instanceof String) ? max.charCodeAt(0) : max;\n        return satisfy((_, i) => min <= i && i <= max);\n    }\n    Parsect.range = range;\n    function charCode(charCode) {\n        assert(typeof charCode === \"number\" || charCode instanceof Number);\n        return satisfy((_, i) => i === charCode);\n    }\n    Parsect.charCode = charCode;\n    function makeTokenParser(def) {\n        /////////////////////////////////////////////////////////////////////////////////////////\n        // White space & symbols\n        ////////////////////////////////////////////////////////////////////////////////////////////\n        function symbol(name) {\n            return lexeme(string(name));\n        }\n        function lexeme(p) {\n            return seq(s => {\n                var x = s(p);\n                s(whiteSpace);\n                return x;\n            });\n        }\n        // whiteSpace\n        //var noLine  = def.commentLine.length == 0;\n        //var noMulti = def.commentStart.length == 0;\n        var noLine = def.commentLine === null;\n        var noMulti = def.commentStart === null;\n        //var commentStart = triable(string(def.commentStart));\n        //var commentEnd = triable(string(def.commentEnd));\n        //var startEnd = (def.commentEnd + def.commentStart).split('').filter((x, i, xs)=>xs.indexOf(x) === i).join(\"\");\n        var commentStart = triable(def.commentStart);\n        var commentEnd = triable(def.commentEnd);\n        var oneLineComment = seq(s => {\n            //s(triable(string(def.commentLine)));\n            s(triable(def.commentLine));\n            s(skipMany(satisfy(x => x != '\\n')));\n            return undefined;\n        });\n        var multiLineComment = seq(s => {\n            s(commentStart);\n            return s(inComment);\n        });\n        var inCommentMulti = label(\"end of comment\", or(seq(s => { s(commentEnd); }), seq(s => { s(multiLineComment); s(inCommentMulti); }), \n        //seq(s=>{ s(skipMany1(noneOf(startEnd)));    s(inCommentMulti) }),\n        //seq(s=>{ s(oneOf(startEnd));                s(inCommentMulti); })\n        seq(s => { s(notFollowedBy(commentEnd)); s(Parsect.anyChar); s(inCommentMulti); })));\n        var inCommentSingle = label(\"end of comment\", or(seq(s => { s(commentEnd); }), \n        //seq(s=>{ s(skipMany1(noneOf(startEnd))); s(inCommentSingle); }),\n        //seq(s=>{ s(oneOf(startEnd)); s(inCommentSingle); })\n        seq(s => { s(notFollowedBy(commentEnd)); s(Parsect.anyChar); s(inCommentSingle); })));\n        var inComment = def.nestedComments ? inCommentMulti : inCommentSingle;\n        var simpleSpace = skipMany1(oneOf(\" \\t\\r\\n\"));\n        var whiteSpace = noLine && noMulti ? skipMany(simpleSpace) :\n            noLine ? skipMany(or(simpleSpace, multiLineComment)) :\n                noMulti ? skipMany(or(simpleSpace, oneLineComment)) :\n                    skipMany(or(simpleSpace, oneLineComment, multiLineComment));\n        ////////////////////////////////////////////////////////////////////////////////////\n        // Operators & reserved ops\n        ////////////////////////////////////////////////////////////////////////////////////////\n        function reservedOp(name) {\n            return lexeme(triable(seq(s => {\n                var n = s(string(name));\n                s(notFollowedBy(def.opLetter));\n                return n;\n            })));\n        }\n        var operator = lexeme(triable(seq(s => {\n            var name = s(oper);\n            return isReservedOp(name) ? s(unexpected(\"reserved operator \" + name)) : name;\n        })));\n        if ((def.operator && (def.opStart || def.opLetter)) ||\n            (!def.operator && !def.opStart && !def.opLetter)) {\n            throw new Error();\n        }\n        var oper = def.operator || seq(s => {\n            var c = s(def.opStart);\n            var cs = s(Join.many(def.opLetter));\n            return c + cs;\n        });\n        function isReservedOp(name) {\n            return def.reservedOpNames.indexOf(name) >= 0;\n        }\n        /////////////////////////////////////////////////////////////////////////\n        // Identifiers & Reserved words\n        /////////////////////////////////////////////////////////////////////////////////////////\n        function reserved(name) {\n            return lexeme(triable(label(\"end of \" + name, seq(s => {\n                var n = s(string(name, def.caseSensitive));\n                s(notFollowedBy(def.identLetter));\n                return n;\n            }))));\n        }\n        var identifier = lexeme(triable(seq(s => {\n            var name = s(ident);\n            if (isReservedName(name)) {\n                return s(unexpected(\"reserved word \" + name));\n            }\n            else {\n                return name;\n            }\n        })));\n        var ident = label(\"identifier\", seq(s => {\n            var c = s(def.identStart);\n            var cs = s(Join.many(def.identLetter));\n            return s.success && (c + cs);\n        }));\n        var theReservedNames = def.caseSensitive ? def.reservedNames : def.reservedNames.map(n => n.toLowerCase());\n        function isReservedName(name) {\n            var caseName = def.caseSensitive ? name : name.toLowerCase();\n            return theReservedNames.indexOf(caseName) >= 0;\n        }\n        ////////////////////////////////////////////////////////////////////////////////\n        // Bracketing\n        //////////////////////////////////////////////////////////////////////////////////////\n        function parens(p) {\n            return between(symbol(\"(\"), p, symbol(\")\"));\n        }\n        function braces(p) {\n            return between(symbol(\"{\"), p, symbol(\"}\"));\n        }\n        function angles(p) {\n            return between(symbol(\"<\"), p, symbol(\">\"));\n        }\n        function brackets(p) {\n            return between(symbol(\"[\"), p, symbol(\"]\"));\n        }\n        var semi = symbol(\";\");\n        var comma = symbol(\",\");\n        var dot = symbol(\".\");\n        var colon = symbol(\":\");\n        function commaSep(p) {\n            return sepBy(p, comma);\n        }\n        function semiSep(p) {\n            return sepBy(p, semi);\n        }\n        function commaSep1(p) {\n            return sepBy1(p, comma);\n        }\n        function semiSep1(p) {\n            return sepBy1(p, semi);\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////\n        // Chars & Strings\n        //////////////////////////////////////////////////////////////////////////////\n        var escapeCode = seq(s => {\n            var c = s(satisfy(_ => true));\n            switch (c) {\n                case \"r\": return \"\\r\";\n                case \"n\": return \"\\n\";\n                default: return s(unexpected(c));\n            }\n        });\n        var charLetter = satisfy((c, i) => (c != \"'\") && (c != \"\\\\\") && (i > 26));\n        var charEscape = seq(s => {\n            s(string('\\\\'));\n            return s(escapeCode);\n        });\n        var characterChar = label(\"literal character\", or(charLetter, charEscape));\n        var charLiteral = label(\"character\", lexeme(between(string('\\''), characterChar, label(\"end of character\", string('\\'')))));\n        var escapeEmpty = string('&');\n        var escapeGap = seq((s) => {\n            s(many1(Parsect.space));\n            return s(label(\"end of string gap\", string('\\\\')));\n        });\n        var stringEscape = seq(s => {\n            s(string('\\\\'));\n            return s(or(seq(s => {\n                s(escapeGap);\n                return s(pure(null));\n            }), seq(s => {\n                s(escapeEmpty);\n                return s(pure(null));\n            }), escapeCode));\n        });\n        var stringLetter = satisfy((c, i) => (c != '\"') && (c != '\\\\') && (i > 26));\n        var stringChar = label(\"string character\", or(stringLetter, stringEscape));\n        var stringLiteral = label(\"literal string\", lexeme(fmap(xs => xs.join(''), between(string('\"'), many(stringChar), label(\"end of string\", string('\"'))))));\n        // integers and naturals\n        function number(base, baseDigit) {\n            assert(!!baseDigit);\n            return fmap((xs) => xs.reduce((x, d) => base * x + parseInt(d), 0), many1(baseDigit));\n        }\n        var decimal = number(10, Parsect.digit);\n        var hexadecimal = seq((s) => {\n            s(oneOf(\"xX\"));\n            return s(number(16, Parsect.hexDigit));\n        });\n        var octal = seq(s => {\n            s(oneOf(\"oO\"));\n            return s(number(8, Parsect.octDigit));\n        });\n        var zeroNumber = label(\"\", seq((s) => {\n            s(string('0'));\n            return s(or(hexadecimal, octal, decimal, pure(0)));\n        }));\n        var nat = or(zeroNumber, decimal);\n        var sign = or(seq((s) => {\n            s(string('-'));\n            return s(pure((x) => -x));\n        }), seq((s) => {\n            s(string('+'));\n            return s(pure((x) => x));\n        }), pure((x) => x));\n        var int = seq(s => {\n            var f = s(lexeme(sign));\n            var n = s(nat);\n            return s.success ? f(n) : undefined;\n        });\n        //  -- floats\n        var exponent$ = label(\"exponent\", seq((s) => {\n            function power(e) {\n                return e < 0 ? 1.0 / power(-e) : (10 ^ e);\n            }\n            s(oneOf(\"eE\"));\n            var f = s(sign);\n            var e = s(label(\"exponent\", decimal));\n            return s.success ? power(f(e)) : undefined;\n        }));\n        var fraction = seq(s => {\n            s(string('.'));\n            var digits = s(label(\"fraction\", many1(Parsect.digit)));\n            function op(d, f) {\n                return (f + d) / 10.0;\n            }\n            return s.success ? digits.reduce(op, 0.0) : undefined;\n        });\n        function fractExponent(n) {\n            return or(seq(s => {\n                var fract = s(fraction);\n                var expo = s(option(1.0, exponent$));\n                return s.success ? (n + fract) * expo : undefined;\n            }), seq(s => {\n                var expo = s(exponent$);\n                return s.success ? (n * expo) : undefined;\n            }));\n        }\n        var floating = seq(s => {\n            var n = s(decimal);\n            return s(fractExponent(n));\n        });\n        function fractFloat(n) {\n            return fractExponent(n);\n        }\n        var decimalFloat = seq(s => {\n            var n = s(decimal);\n            return s(option(n, fractFloat(n)));\n        });\n        var zeroNumFloat = or(or(hexadecimal, octal), decimalFloat, fractFloat(0), pure(0));\n        var natFloat = or(seq((s) => {\n            s(string('0'));\n            return s(zeroNumFloat);\n        }), decimalFloat);\n        var naturalOrFloat = label(\"number\", lexeme(natFloat));\n        var float = label(\"float\", lexeme(floating));\n        var integer = label(\"integer\", lexeme(int));\n        var natural = label(\"natural\", lexeme(nat));\n        return {\n            identifier: identifier,\n            reserved: reserved,\n            operator: operator,\n            reservedOp: reservedOp,\n            charLiteral: charLiteral,\n            stringLiteral: stringLiteral,\n            natural: natural,\n            integer: integer,\n            float: float,\n            naturalOrFloat: naturalOrFloat,\n            decimal: decimal,\n            hexadecimal: hexadecimal,\n            octal: octal,\n            symbol: symbol,\n            lexeme: lexeme,\n            whiteSpace: whiteSpace,\n            parens: parens,\n            braces: braces,\n            angles: angles,\n            brackets: brackets,\n            squares: brackets,\n            semi: semi,\n            comma: comma,\n            colon: colon,\n            dot: dot,\n            semiSep: semiSep,\n            semiSep1: semiSep1,\n            commaSep: commaSep,\n            commaSep1: commaSep1\n        };\n    }\n    Parsect.makeTokenParser = makeTokenParser;\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Expression Parser (Text.Parsec.Expr) /////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Parsec-compatible interface\n    let Assoc;\n    (function (Assoc) {\n        Assoc[Assoc[\"None\"] = 0] = \"None\";\n        Assoc[Assoc[\"Left\"] = 1] = \"Left\";\n        Assoc[Assoc[\"Right\"] = 2] = \"Right\";\n    })(Assoc = Parsect.Assoc || (Parsect.Assoc = {}));\n    class LAssoc {\n        constructor(p) {\n            this.p = p;\n        }\n    }\n    class RAssoc {\n        constructor(p) {\n            this.p = p;\n        }\n    }\n    class NAssoc {\n        constructor(p) {\n            this.p = p;\n        }\n    }\n    class Prefix {\n        constructor(p) {\n            this.p = p;\n        }\n    }\n    class Postfix {\n        constructor(p) {\n            this.p = p;\n        }\n    }\n    function infix(p, assoc) {\n        switch (assoc) {\n            case Assoc.None: return new NAssoc(p);\n            case Assoc.Left: return new LAssoc(seq(s => {\n                return s(p);\n            }));\n            case Assoc.Right: return new RAssoc(p);\n        }\n    }\n    Parsect.infix = infix;\n    function prefix(p) {\n        return new Prefix(p);\n    }\n    Parsect.prefix = prefix;\n    function postfix(p) {\n        return new Postfix(p);\n    }\n    Parsect.postfix = postfix;\n    function buildExpressionParser(operatorTable, simpleExpr) {\n        return makeExpressionParser(operatorTable.map((ops) => {\n            var rassoc = ops.filter(op => op instanceof RAssoc);\n            var lassoc = ops.filter(op => op instanceof LAssoc);\n            var nassoc = ops.filter(op => op instanceof NAssoc);\n            var prefix = ops.filter(op => op instanceof Prefix);\n            var postfix = ops.filter(op => op instanceof Postfix);\n            return new OperatorTable(rassoc.map(r => r.p), lassoc.map(r => r.p), nassoc.map(r => r.p), prefix.map(r => r.p), postfix.map(r => r.p));\n        }), simpleExpr);\n    }\n    Parsect.buildExpressionParser = buildExpressionParser;\n    // Parsect internal interface\n    class OperatorTable {\n        constructor(infixr = [], infixl = [], infix = [], prefix = [], postfix = []) {\n            this.infixr = infixr;\n            this.infixl = infixl;\n            this.infix = infix;\n            this.prefix = prefix;\n            this.postfix = postfix;\n        }\n    }\n    Parsect.OperatorTable = OperatorTable;\n    function makeExpressionParser(table, simpleExpr) {\n        return table.reduce((term, ops) => {\n            var rassocOp = choice(ops.infixr);\n            var lassocOp = choice(ops.infixl);\n            var nassocOp = choice(ops.infix);\n            var prefixOp = choice(ops.prefix);\n            var postfixOp = choice(ops.postfix);\n            function ambigious(assoc, op) {\n                return triable(seq(s => {\n                    s(op);\n                    return s(fail(\"ambiguous use of a \" + assoc + \" associative operator\"));\n                }));\n            }\n            var ambigiousRight = ambigious(\"right\", rassocOp);\n            var ambigiousLeft = ambigious(\"left\", lassocOp);\n            var ambigiousNon = ambigious(\"non\", nassocOp);\n            var termP = seq(s => {\n                var pre = s(prefixP);\n                var x = s(term);\n                var post = s(postfixP);\n                return s.success && post(pre(x));\n            });\n            var postfixP = or(postfixOp, pure((x) => x));\n            var prefixP = or(prefixOp, pure((x) => x));\n            function rassocP(x) {\n                return or(seq(s => {\n                    var f = s(rassocOp);\n                    var y = s(seq(s => { var z = s(termP); return s(rassocP1(z)); }));\n                    return s.success && f(x, y);\n                }), ambigiousLeft, ambigiousNon);\n            }\n            function rassocP1(x) {\n                return or(rassocP(x), pure(x));\n            }\n            function lassocP(x) {\n                return or(seq(s => {\n                    var f = s(lassocOp);\n                    var y = s(termP);\n                    return s.success && s(lassocP1(f(x, y)));\n                }), ambigiousRight, ambigiousNon);\n            }\n            function lassocP1(x) {\n                return or(lassocP(x), pure(x));\n            }\n            function nassocP(x) {\n                return seq(s => {\n                    var f = s(nassocOp);\n                    var y = s(termP);\n                    return s.success && s(or(ambigiousRight, ambigiousLeft, ambigiousNon, pure(f(x, y))));\n                });\n            }\n            return seq(s => {\n                var x = s(termP);\n                return s.success && s(label(\"operator\", or(rassocP(x), lassocP(x), nassocP(x), pure(x))));\n            });\n        }, simpleExpr);\n    }\n    Parsect.makeExpressionParser = makeExpressionParser;\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Util //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function breakPoint(parser) {\n        function breakPointParser(state) {\n            debugger;\n            return parse(parser, state);\n        }\n        return new Parser(breakPointParser);\n    }\n    Parsect.breakPoint = breakPoint;\n    function progress(f) {\n        assert(f instanceof Function);\n        var count = 0;\n        function logParser(state) {\n            var pos = Math.floor(state.position / state.source.length);\n            if (pos > count) {\n                count = pos;\n                f(count);\n            }\n            return ok(state, undefined);\n        }\n        ;\n        return new Parser(logParser);\n    }\n    Parsect.progress = progress;\n    // assert argument conditions.\n    function assert(condition) {\n        if (!condition)\n            throw new Error(\"Argument Assertion Error\");\n    }\n    /// Compare two jsons\n    function jsonEq(a, b) {\n        if ((typeof a === \"boolean\") || (typeof b === \"boolean\") ||\n            (typeof a === \"string\") || (typeof b === \"string\") ||\n            (typeof a === \"number\") || (typeof b === \"number\") ||\n            (typeof a === \"undefined\") || (typeof b === \"undefined\") ||\n            (a === null) || (b === null)) {\n            return a === b;\n        }\n        else if (a instanceof Function || b instanceof Function) {\n            throw new Error();\n        }\n        else if (a instanceof RegExp || b instanceof RegExp) {\n            return a === b;\n        }\n        else if (a instanceof Array || b instanceof Array) {\n            var xs = a, ys = b;\n            return xs instanceof Array && ys instanceof Array && xs.every((x, i) => jsonEq(ys[i], x));\n        }\n        else {\n            var f = true;\n            for (var x in a) {\n                f = f && (x in b && jsonEq(a[x], b[x]) || true);\n            }\n            for (var x in b) {\n                f = f && (x in a && jsonEq(b[x], a[x]) || true);\n            }\n        }\n        return f;\n    }\n    Parsect.jsonEq = jsonEq;\n    let Join;\n    (function (Join) {\n        function many(p) { return fmap(x => x.join(''), Parsect.many(p)); }\n        Join.many = many;\n        function many1(p) { return fmap(x => x.join(''), Parsect.many1(p)); }\n        Join.many1 = many1;\n        function sepBy1(p, q) { return fmap(x => x.join(''), Parsect.sepBy1(p, q)); }\n        Join.sepBy1 = sepBy1;\n        function sepByN(m, n, p, q) { return fmap(x => x.join(''), Parsect.sepByN(m, n, p, q)); }\n        Join.sepByN = sepByN;\n        function repeat(m, n, p) { return fmap(x => x.join(''), Parsect.repeat(m, n, p)); }\n        Join.repeat = repeat;\n        function array(ps) { return fmap(x => x.join(''), Parsect.array(ps)); }\n        Join.array = array;\n        function series(...ps) { return fmap(x => x.join(''), Parsect.array(ps)); }\n        Join.series = series;\n    })(Join = Parsect.Join || (Parsect.Join = {}));\n})(Parsect = exports.Parsect || (exports.Parsect = {}));\n\n\n//# sourceURL=webpack:///./src/Compiler/lib/parsect.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_compiler_1 = __webpack_require__(/*! ./index_compiler */ \"./src/index_compiler.ts\");\n// run_kernel()\nindex_compiler_1.default();\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/index_compiler.ts":
/*!*******************************!*\
  !*** ./src/index_compiler.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Parser_1 = __webpack_require__(/*! ./Compiler/Parser */ \"./src/Compiler/Parser.ts\");\nfunction run_compiler() {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(Parser_1.default(\"use abc;\"));\n    });\n}\nexports.default = run_compiler;\n\n\n//# sourceURL=webpack:///./src/index_compiler.ts?");

/***/ })

/******/ });